\import Data.Unit
\import Data.Vector
\import Equiv
\import Equiv.Univalence
\import Logic
\import Paths
\import Set
\import TRS.Signature
\import TRS.Term
\import Utils.Nat
\import Utils.Vector

\func termUnit {S : Signature}
               {V : \Set}
               (t : Term S V)
  : \Type
  | Var _ => Unit
  | Fun _ _ => Empty

\func contradictionNotEq {S : Signature}
                         {V : \Set}
                         {x : V}
                         {f : S.symbol}
                         {v : Vector (S.arity f) (Term S V)}
                         (p : Var x = Fun f v)
  : Empty =>
  Map.f {=-to-Equiv (pmap termUnit p)} T

\instance TermDecSet
  {S : Signature}
  {V : DecSet}
: DecSet (Term S V)
  | # => apartness
  | #-irreflexive => {?}
  | #-symmetric => {?}
  | #-comparison => {?}
  | tightness => {?}
  | decideEq => {?}
  \where {
    \func apartness {S : Signature}
                    {V : DecSet}
                    (t1 : Term S V)
                    (t2 : Term S V)
      : \Prop
      | Var v1, Var v2 => v1 # v2
      | Var v1, Fun f2 v2 => Empty
      | Fun f1 v1, Var v2 => Empty
      | Fun f1 v1, Fun f2 v2 =>
        (f1 # f2) ||
        (arity f1 NatDecSet.# arity f2) ||
        (\Pi (p : arity f1 = arity f2) -> v1 VectorDecSet.# (transportInv (\lam x => Vector x _) p v2))

    -- ???
  }