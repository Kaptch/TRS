\import Function.Meta
\import Logic
\import Paths
\import Paths.Meta
\import TRS.Context
\import TRS.Signature
\import TRS.Term
\import Data.Vector \using (length \as lengthVec)
\import Relation.Core \using (inclusion \as inclusionRel, reflexive \as isReflexive, transitive \as isTransitive)
\import Relation.Wellfounded \using (wellFounded \as isWellFounded)

\func substitution {S : Signature}
                   {V : \Set}
  : \Type =>
  V -> Term S V

\func id  {S : Signature}
          {V : \Set}
  : substitution {S} {V} =>
  \lam (x : V) => Var x

\func substitute {S : Signature}
                 {V : \Set}
                 (s : substitution {S} {V})
                 (t : Term S V)
  : Term S V
  | s, Var x => s x
  | s, Fun f v => Fun f (substituteVec s v)
  \where
    \func substituteVec {S : Signature}
                        {V : \Set}
                        {i : Nat}
                        (s : substitution {S} {V})
                        (v : Vector i (Term S V))
      : Vector i (Term S V)
      | {S}, {V}, {0}, s, Nil => Nil
      | {S}, {V}, {suc n}, s, Cons a' v' => Cons (substitute s a') (substituteVec s v')

\func composition {S : Signature}
                  {V : \Set}
                  (s1 : substitution {S} {V})
                  (s2 : substitution {S} {V})
  : substitution {S} {V} =>
  \lam (v : V) => substitute s1 (s2 v)

\func substituteSubstitute {S : Signature}
                           {V : \Set}
                           (s1 : substitution {S} {V})
                           (s2 : substitution {S} {V})
                           (t : Term S V)
  : substitute s1 (substitute s2 t) = substitute (composition s1 s2) t =>
  term_ind
      (\lam t => substitute s1 (substitute s2 t) = substitute (composition s1 s2) t)
      (\lam n => \lam v => substitute.substituteVec s1 (substitute.substituteVec s2 v) = substitute.substituteVec (composition s1 s2) v)
      (\lam _ => idp)
      (\lam f => \lam v => \lam p => pmap (Fun f) p)
      idp
      (\lam t => \lam n => \lam v => \lam p => \lam pv => pmap2 Cons p pv)
      t

\func substitutionPreservesRelation {S : Signature}
                                    {V : \Set}
                                    {rel : relation (Term S V)}
  : \Type =>
  \Pi (t1 : Term S V) ->
      \Pi (t2 : Term S V) ->
          \Pi (r : rel t1 t2) ->
              \Pi (sub : substitution {S} {V}) ->
                  rel (substitute sub t1) (substitute sub t2)

\func subsumes {S : Signature}
               {V : \Set}
               (s : Term S V)
               (t : Term S V)
  : \Prop =>
  TruncP (\Sigma (delta : substitution) (s = substitute delta t))
  \where {
    \func reflexive {S : Signature}
                    {V : \Set}
      : isReflexive (subsumes {S} {V}) =>
      \lam (t : Term S V) => inP (Var, inv (help1 t))
      \where {
        \func help1 {S : Signature}
                    {V : \Set}
                    (t : Term S V)
          : substitute Var t = t
          | Var v => idp
          | Fun f v => pmap (Fun f) (help2 v)

        \func help2 {S : Signature}
                    {V : \Set}
                    {i : Nat}
                    (v : Vector i (Term S V))
          : substitute.substituteVec Var v = v
          | {S}, {V}, {0}, Vector.Nil => idp
          | {S}, {V}, {suc n}, Vector.Cons a' v' => pmap2 Cons (help1 a') (help2 v')
      }

    \func transitive {S : Signature}
                     {V : \Set}
      : isTransitive (subsumes {S} {V}) =>
      \lam (x y z : Term S V) =>
          \lam (r1 : subsumes x y) =>
              \lam (r2 : subsumes y z) => \scase r1, r2 \with {
                | inP a', inP a'' =>
                  inP (composition a'.1 a''.1, a'.2 *> pmap (substitute a'.1) a''.2 *> (help1 z a'.1 a''.1))
              }
      \where {
        \func help1  {S : Signature}
                     {V : \Set}
                     (x : Term S V)
                     (a1 : substitution {S} {V})
                     (a2 : substitution {S} {V})
          : substitute a1 (substitute a2 x) = substitute (composition a1 a2) x
          | Var v, a1, a2 => idp
          | Fun f v, a1, a2 => pmap (Fun f) (help2 v a1 a2)

        \func help2  {S : Signature}
                     {V : \Set}
                     {i : Nat}
                     (v : Vector i (Term S V))
                     (a1 : substitution {S} {V})
                     (a2 : substitution {S} {V})
          : substitute.substituteVec a1 (substitute.substituteVec a2 v) = substitute.substituteVec (composition a1 a2) v
          | {S}, {V}, {0}, Vector.Nil, a1, a2 => idp
          | {S}, {V}, {suc n}, Vector.Cons a' v', a1, a2 => pmap2 Cons (help1 a' a1 a2) (help2 v' a1 a2)
      }
  }

\func substituteContext {S : Signature}
                        {V : \Set}
                        (s : substitution {S} {V})
                        (c : Context S V)
  : Context S V
  | _, Hole => Hole
  | s, Cont f i j p t1 c' t2 => Cont f i j p (substitute.substituteVec s t1) (substituteContext s c') (substitute.substituteVec s t2)

-- TODO

\func substituteFill {S : Signature}
                     {V : \Set}
                     (t : Term S V)
                     (s : substitution {S} {V})
                     (c : Context S V)
  : substitute s (fill c t) = fill (substituteContext s c) (substitute s t) =>
  context_ind (\lam x => substitute s (fill x t) = fill (substituteContext s x) (substitute s t))
              idp
              (\lam c f i j p t1 t2 hyp => {?})
              c

-- Fun f (substituteVec s (transport (\lam k => Vector k (Term S V)) p (concat t1 (Cons (fill c t) t2))))
-- =
-- Fun f (transport (\lam k => Vector k (Term S V)) p (concat (substituteVec s t1) (Cons (fill (substituteContext s c) (substitute s t)) (substituteVec s t2))))

-- pmap (Fun f)

-- substituteVec s (transport (\lam k => Vector k (Term S V)) p (concat t1 (Cons (fill c t) t2)))
-- =
-- transport (\lam k => Vector k (Term S V)) p (concat (substituteVec s t1) (Cons (fill (substituteContext s c) (substitute s t)) (substituteVec s t2)))

-- substituteVecMap

-- map (substitute s) (transport (\lam k => Vector k (Term S V)) p (concat t1 (Cons (fill c t) t2)))
-- =
-- transport (\lam k => Vector k (Term S V)) p (concat (substituteVec s t1) (Cons (fill (substituteContext s c) (substitute s t)) (substituteVec s t2)))

-- transportMap

-- transport (\lam k => Vector k (Term S V)) p (map (substitute s) (concat t1 (Cons (fill c t) t2)))
-- =
-- transport (\lam k => Vector k (Term S V)) p (concat (substituteVec s t1) (Cons (fill (substituteContext s c) (substitute s t)) (substituteVec s t2)))

-- pmap (transport (\lam k => Vector k (Term S V)) p)

-- map (substitute s) (concat t1 (Cons (fill c t) t2))
-- =
-- concat (substituteVec s t1) (Cons (fill (substituteContext s c) (substitute s t)) (substituteVec s t2))

-- hyp

-- map (substitute s) (concat t1 (Cons (fill c t) t2))
-- =
-- concat (substituteVec s t1) (Cons (substitute s (fill c t)) (substituteVec s t2))

-- substituteVecMap 2

-- map (substitute s) (concat t1 (Cons (fill c t) t2))
-- =
-- concat (map (substitute s) t1) (Cons (substitute s (fill c t)) (map (substitute s) t2))

-- consMap

-- map (substitute s) (concat t1 (Cons (fill c t) t2))
-- =
-- concat (map (substitute s) t1) (map (substitute s) (Cons (fill c t) t2))

-- concatMap

-- map (substitute s) (concat t1 (Cons (fill c t) t2))
-- =
-- map (substitute s) (concat t1 (Cons (fill c t) t2))

-- idp

\func consSubstituteVec {S : Signature}
                        {V : \Set}
                        {i : Nat}
                        (s : substitution {S} {V})
                        (c : Context S V)
                        (t : Term S V)
                        (v : Vector i (Term S V))
  : (Cons (substitute s (fill c t)) (substitute.substituteVec s v)) = (substitute.substituteVec s (Cons (fill c t) v)) =>
  \let
    | x => rewrite (substituteVecMap s v) (consMap (substitute s) (fill c t) v)
  \in rewrite (substituteVecMap s v) (inv x)

\func substituteVecMap  {S : Signature}
                        {V : \Set}
                        {i : Nat}
                        (s : substitution {S} {V})
                        (v : Vector i (Term S V))
  : substitute.substituteVec s v = map (substitute s) v
  | {S}, {V}, {0}, s, Vector.Nil => idp
  | {S}, {V}, {suc i}, s, Vector.Cons a' v' => pmap (Cons (substitute s a')) (substituteVecMap s v')