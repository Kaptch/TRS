\import Logic
\import Paths
\import TRS.Signature
\import TRS.Term
\import Data.Vector \using (length \as lengthVec)
\import Relation.Core \using (reflexive \as isReflexive, transitive \as isTransitive)
\import Relation.Wellfounded \using (wellFounded \as isWellFounded)

\func substitution {S : Signature}
                   {V : \Set}
  : \Type =>
  V -> Term S V

\func id  {S : Signature}
          {V : \Set}
  : substitution {S} {V} =>
  \lam (x : V) => Var x

\func substitute {S : Signature}
                 {V : \Set}
                 (s : substitution {S} {V})
                 (t : Term S V)
  : Term S V
  | s, Var x => s x
  | s, Fun f v => Fun f (substituteVec s v)
  \where
    \func substituteVec {S : Signature}
                        {V : \Set}
                        {i : Nat}
                        (s : substitution {S} {V})
                        (v : Vector i (Term S V))
      : Vector i (Term S V)
      | {S}, {V}, {0}, s, Nil => Nil
      | {S}, {V}, {suc n}, s, Cons a' v' => Cons (substitute s a') (substituteVec s v')

\func composition {S : Signature}
                  {V : \Set}
                  (s1 : substitution {S} {V})
                  (s2 : substitution {S} {V})
  : substitution {S} {V} =>
  \lam (v : V) => substitute s1 (s2 v)

\func substitutionPreservesRelation {S : Signature}
                                    {V : \Set}
                                    {rel : relation (Term S V)}
  : \Type =>
  \Pi (t1 : Term S V) ->
      \Pi (t2 : Term S V) ->
          \Pi (r : rel t1 t2) ->
              \Pi (sub : substitution {S} {V}) ->
                  rel (substitute sub t1) (substitute sub t2)

\func subsumes {S : Signature}
               {V : \Set}
               (s : Term S V)
               (t : Term S V)
  : \Prop =>
  TruncP (\Sigma (delta : substitution) (s = substitute delta t))
  \where {
    \func reflexive {S : Signature}
                    {V : \Set}
      : isReflexive (subsumes {S} {V}) =>
      \lam (t : Term S V) => inP (Var, inv (help1 t))
      \where {
        \func help1 {S : Signature}
                    {V : \Set}
                    (t : Term S V)
          : substitute Var t = t
          | Var v => idp
          | Fun f v => pmap (Fun f) (help2 v)

        \func help2 {S : Signature}
                    {V : \Set}
                    {i : Nat}
                    (v : Vector i (Term S V))
          : substitute.substituteVec Var v = v
          | {S}, {V}, {0}, Vector.Nil => idp
          | {S}, {V}, {suc n}, Vector.Cons a' v' => pmap2 Cons (help1 a') (help2 v')
      }

    \func transitive {S : Signature}
                     {V : \Set}
      : isTransitive (subsumes {S} {V}) =>
      \lam (x y z : Term S V) =>
          \lam (r1 : subsumes x y) =>
              \lam (r2 : subsumes y z) => \scase r1, r2 \with {
                | inP a', inP a'' =>
                  inP (composition a'.1 a''.1, a'.2 *> pmap (substitute a'.1) a''.2 *> (help1 z a'.1 a''.1))
              }
      \where {
        \func help1  {S : Signature}
                     {V : \Set}
                     (x : Term S V)
                     (a1 : substitution {S} {V})
                     (a2 : substitution {S} {V})
          : substitute a1 (substitute a2 x) = substitute (composition a1 a2) x
          | Var v, a1, a2 => idp
          | Fun f v, a1, a2 => pmap (Fun f) (help2 v a1 a2)

        \func help2  {S : Signature}
                     {V : \Set}
                     {i : Nat}
                     (v : Vector i (Term S V))
                     (a1 : substitution {S} {V})
                     (a2 : substitution {S} {V})
          : substitute.substituteVec a1 (substitute.substituteVec a2 v) = substitute.substituteVec (composition a1 a2) v
          | {S}, {V}, {0}, Vector.Nil, a1, a2 => idp
          | {S}, {V}, {suc n}, Vector.Cons a' v', a1, a2 => pmap2 Cons (help1 a' a1 a2) (help2 v' a1 a2)
      }
  }