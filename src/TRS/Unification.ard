\import Logic
\import Paths
\import Paths.Meta
\import Set
\import TRS.Signature
\import TRS.Substitution
\import TRS.Term

\func isUnifier {S : Signature}
                {V : \Set}
                (s : substitution {S} {V})
                (t1 t2 : Term S V)
  : \Prop =>
  substitute s t1 = substitute s t2

\func unifiable {S : Signature}
                {V : \Set}
                (t1 t2 : Term S V)
  : \Prop =>
  TruncP (\Sigma (s : substitution {S} {V})
                 (isUnifier s t1 t2))

\func isMGU {S : Signature}
            {V : \Set}
            (s : substitution {S} {V})
            (t1 t2 : Term S V)
  : \Prop =>
  TruncP (\Sigma (isUnifier s t1 t2)
                 (\Pi (q : substitution {S} {V}) -> isUnifier q t1 t2 -> extends q s))

\func isMGU' {S : Signature}
             {V : \Set}
             (s : substitution {S} {V})
             (t1 t2 : Term S V)
  : \Prop =>
  TruncP (\Sigma (isUnifier s t1 t2)
                 (\Pi (q : substitution {S} {V}) -> isUnifier q t1 t2 -> extends' q s))

\func unification {S : Signature}
                  {V : DecSet}
                  (t1 t2 : Term S V)
                  (u : unifiable t1 t2)
  : TruncP (\Sigma (s : substitution {S} {V})
                   (isMGU s t1 t2))
  | {S}, {V}, Var v1, Var v2, inP a => \case decideEq v1 v2 \with {
    | yes e => inP (id, inP (pmap (substitute id) (pmap Var e), \lam _ _ _ n => absurd (n idp)))
    | no n =>
      \let
        | A => transportInv (\lam x => x = Var v2) (singleSubsElimEq {S} v1 (Var v2)) idp
        | B => transportInv (\lam x => substitute (single v1 (Var v2)) (Var v1) = x) (singleSubsElimNotEq v1 (Var v2) v2 n) A
      \in
        inP (single v1 (Var v2), inP (B, (\lam q' u' x' n' => \case decideEq x' v1, decideEq x' v2 \with {
          | yes e1, yes e2 =>
            absurd (n' (transportInv (\lam r => single v1 (Var v2) x' = Var r) e2 (transportInv (\lam r => single v1 (Var v2) r = Var v2) e1 (singleElimEq v1 (Var v2)))))
          | yes e1, no n2 => {?}
          | no n1, yes e2 => {?}
          | no n1, no n2 => {?}
        })))
  }
  | Var v1, Fun f2 v2, inP a => inP (single v1 (Fun f2 v2), {?})
  | Fun f1 v1, Var v2, inP a => inP (single v2 (Fun f1 v1), {?})
  | Fun f1 v1, Fun f2 v2, inP a => {?}